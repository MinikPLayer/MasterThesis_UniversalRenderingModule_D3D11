\chapter{Podsumowanie}
Głównym problemem obecnej branży systemów grafiki trójwymiarowej jest ich wysoka złożoność i/lub niska elastyczność. Brakuje przez to na rynku uniwersalnego rozwiązania wyższego od bezpośredniego API graficznego, ale bardziej modyfikowalnego niż pełnoprawne silniki do gier. Zmusza to twórców aplikacji wykorzystujących techniki rysowania w trzech wymiarach do tworzenia autorskich, często bardzo kosztownych rozwiązań.

Praca opisuje rozwiązanie takiego problemu - implementacja systemu nazwanego \textbf{Universal Rendering Module (URM)}, będącego zbiorem warstwowych modułów mających na celu uzupełnienie luk w dostępnych rozwiązaniach, tak aby móc stać się docelową biblioteką niezależnie od specyficznych wymagań aplikacji.

Dzięki swojej modularnej architekturze i otwarto-źródłowym projekcie URM może zostać dostosowany do każdego projektu, firmy, czy stylu pracy, co czyni go naprawdę uniwersalnym.

\section{Podsumowanie rozdziałów}
W pierwszych dwóch rozdziałach opisane zostały teoretyczne podstawy renderowania grafiki 3D. Przedstawiono kluczowe zagadnienia dla idealnego systemu - modularność, wydajność, elastyczność - a także opisano najpopularniejsze techniki rysowania - Forward Rendering, Deferred Shading, Path Tracing - modele cieniowania - Phong Shading, PBR - czy efekty graficzne - Ambient Occlusion, Screen Space Reflections. Dokładnie opisana została także historia DirectX i Direct3D, ich architektura i zaawansowane funkcje. 

W kolejnej części przedstawione i uzasadnione zostały decyzje projektowe co do użytych technologii. W tym rozdziale zadecydowano o użyciu Direct3D w wersji 11 jako API graficznego, Assimp do wczytywania trójwymiarowych modeli, czy DirectXTK do funkcji pomocniczych. 

Następnie przedstawione zostały podstawowe założenia architektury systemu. Założenie metodologii warstwowej, dokładnych ram modularności oraz wstępnego projektu interfejsów poszczególnych warstw.

W kolejnym kroku opisano historię procesu tworzenia, od projektu zapoznawczego po implementację poszczególnych warstw. Przedstawione zostały też napotkane problemy i ich rozwiązania, które zawsze pojawiają się w większych projektach. Opisano także szczegóły decyzji o opublikowaniu kodu źródłowego modułu na platformie GitHub. 

W rozdziale 7 pokazane zostały szczegóły przyjętej modyfikacji pierwotnego założenia o metodzie rysowania oświetlenia, co umożliwiło na wyraźne zwiększenie wydajności, zdjęcie limitów maksymalnej ilości świateł, a także zwiększyło potencjał do przeportowania modułu na platformy mobilne. 

Końcowe trzy segmenty opisują testy wydajności poszczególnych komponentów i przyjętą platformę na której je przeprowadzano. Poza bezpośrednimi danymi pokazane zostały także wyróżniające moduł dema technologiczne, zarówno z perspektywy interfejsu aplikacji klienckiej, jak i potencjalnego użytkownika. 

\section{Przebieg badań i kluczowe decyzje projektowe}
Badania rozpoczęto od analizy istniejących na rynku modułów graficznych, jednak żaden z nich nie spełniał przyjętej definicji modularności. Kluczowe decyzje podjęte zostały na podstawie praktycznych testów, gdyż dopiero dzięki wiedzy zdobytej podczas ich przeprowadzania możliwe jest określenie dokładnych wad i zalet każdego z rozwiązań, a także priorytetów na dalszą implementację.

Najważniejszą decyzją był wybór wersji API graficznego, gdyż to od tego zależeć będzie złożoność, ale też możliwości powstającego systemu. Ostatecznie wybór padł na API w wersji 11, ze względu na najlepszy stosunek złożoności do możliwości. Podobną decyzję należało także podjąć w sprawie interfejsu obsługi okien, na które wybrane zostało WinAPI ze względu na swoją wydajność, kompatybilność, stabilność, jak i mnogość dostępnych materiałów i dokumentacji. Wykorzystanie Assimp do wczytywania modeli było oczywistością dzięki bardzo dobrej dokumentacji oraz mnogości wspieranych formatów. Ostateczna decyzja została jednak podjęta dopiero po dokładnym przetestowaniu i sprawdzeniu alternatyw. 

\section{Przebieg implementacji i napotkane problemy}
Najważniejszym elementem przewijającym się przez większość pracy nad systemem była kwestia kompromisu między wydajnością, a modularnością. Te dwa koncepty stoją po przeciwnych stronach i często wzajemnie się wykluczają. Ostatecznym rozwiązaniem okazał się kompromis, według którego priorytetem jest modularność, ale kosztem nie większym niż umiarkowanego spadku wydajności. Okazało się to kluczowym założeniem zmuszającym do ostatecznego zintegrowania modułów sceny i silnika, a także jednym z powodów opublikowania projektu na licencji open source. 

Dodatkowym problematycznym aspektem związanym z wydajnością były problemy wynikające z przypadkowego użycia konstruktorów kopiujących zamiast przenoszących. Problem został rozwiązany wyłączając w kluczowych miejscach mechanizm kopiowania za pomocy klasy bazowej \textit{NonCopyable}, pozostawiając przy tym opcję przenoszenia takich obiektów.

Direct3D obsługuje operacje rysowania zarówno w układzie lewoskrętnym, jak i prawoskrętnym. Nie jest jednak możliwe mieszanie tych systemów, a jest to łatwy do popełnienia błąd i często zdarzał się on podczas prac nad modułem. Ostatecznie przyjęty został zgodny z używanym w branży DirectX układ lewoskrętny, co w połączeniu z odpowiednimi flagami przy wczytywaniu modeli pozwoliło na wyeliminowanie problemu. 

Dzięki użyciu nowoczesnych konceptów języka C++, takich jak \textit{std::variant} czy pakiet \textit{concepts}, możliwa była minimalizacja złożoności użycia modułu z perspektywy aplikacji klienta, bez ograniczenia elastyczności całego systemu. 

\section{Wynik końcowy - sukcesy i porażki}
Głównym sukcesem było osiągnięcie założonego celu projektowego - stworzenia uniwersalnego modułu, który pozwala na bezpośrednie użycie, a także rozszerzenie jego funkcjonalności. Uzupełnia to lukę w dostępnych rozwiązaniach i może stanowić podstawę do bardziej złożonych projektów.

Jako pozytywny aspekt należy także zaliczyć wyraźne ograniczenie złożoności tworzenia aplikacji opartych o grafikę 3D z perspektywy programisty. Zmniejszenie objętości programu wyświetlającego model 3D do kilkudziesięciu linii kodu, bez poświęcania możliwości rozszerzenia funkcjonalności to bardzo istotny aspekt dla wielu użytkowników.

Do sukcesów należy także zaliczyć ilość zaimplementowanych funkcji, takich jak zaawansowana obsługa materiałów i powiązanych z nimi kalkulacji oświetlenia - w tym standardem PBR, obsługa większości dostępnych formatów modeli 3D, czy zaawansowany system sceny i obiektów.

Jako największą porażkę trzeba przyjąć brak pełnej modularności. Koszt wydajnościowy i jakościowy okazał się zbyt wysoki do przeskoczenia, w związku z czym koniecznym był kompromis w sposobie dystrybuowania i użycia gotowej biblioteki. Decyzja ma jednak także zalety, gdyż nawet najlepiej zaprojektowany i uniwersalny moduł zyskuje na możliwości modyfikacji jego kodu. 

Pozostałe wady związane są głównie z pierwotnie przyjętymi założeniami. Oparcie architektury o API DirectX / Direct3D ogranicza moduł głównie do użycia z systemem Windows, z umiarkowanym wsparciem dla Linux oraz macOS przy pomocy DXVK. Jest to jednak kompromis wokół którego moduł został projektowany, więc nie stanowi bezpośredniej porażki. 

Jako wadę przyjąć też można obsługę cieniowania jedynie w trybie Forward Rendering. Mimo że jest to jedna z najbardziej uniwersalnych technik, to nie jest rozwiązaniem idealnym do wszystkich zastosowań.

\section{Podsumowanie testów}
Moduł wykazuje się wystarczającą wydajnością do większości zastosowań, a jego prosty interfejs umożliwia szybkie i proste aplikowanie go w praktycznych zastosowaniach. Przyjęta metoda rysowania świateł pozwala na osiągnięcie bardzo dobrej wydajności niezależnie od mocy obliczeniowej układu graficznego, a także na teoretyczną możliwość obsługi nieskończonej ilości źródeł światła.

Ograniczenia wynikają głównie z przyjęcia Forward Rendering jako jedynej techniki rysowania, a także limitów po stronie CPU ze względu na ograniczenie renderowania i kalkulacji transformacji obiektów do obliczeń pojedynczego rdzenia. 

\section{Możliwości rozbudowy}
Mimo dobrego stanu końcowego projektu kilka aspektów mogłoby zostać rozwinięte, co dodatkowo zwiększyłoby atrakcyjność omawianego modułu. 

Przede wszystkim dodanie większej ilości dostępnych do wyboru efektów, takich jak Screen Space Reflection, Ambient Occlusion, czy obsługa Ray Tracing'u wzbogaciłaby możliwości modułu i zwiększyła jego potencjał do zastosowań w większych projektach. 

Ułatwieniem byłoby też dodanie możliwości wczytywania sceny zapisanej do określonego formatu, takiego jak JSON czy XML. Umożliwiłoby to stworzenie graficznego interfejsu do projektowania światów i pracy zbliżonej do komercyjnych silników graficznych, takich jak Unity czy Unreal Engine.

Dobrym kierunkiem, choć wykraczającym poza pierwotne założenia byłoby też dodanie jeszcze jednej, najniższej warstwy. Odpowiadałby za abstrakcję nad różnymi API graficznymi i pozwalała na uniwersalność względem środowiska i systemu operacyjnego. 