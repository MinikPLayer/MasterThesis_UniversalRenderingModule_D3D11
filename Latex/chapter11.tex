\chapter{Dema funkcjonalności}
Poza samymi testami zaimplementowane zostało także kilka programów typu demo, przedstawiających poszczególne funkcjonalności modułu.

\section{Moduł rdzeniowy}
Ze względu na fakt, iż założenie modularności było jednym z najważniejszych aspektów projektowania projektu, testy i dema zostały podzielone na segmenty, pokazujące różne formy użycia gotowego API modułu. Początkowe testy skupią się na najważniejszym komponencie - warstwie rdzeniowej.

\subsection{Minimalne okno i konfiguracja Direct3D 11}
Pierwszym demem, podstawą prawie każdego projektu opartego o API Direct3D, a jednocześnie testem działania modułu rdzeniowego jest program, którego celem jest utworzenie minimalnej pętli Clear(), Present(), czego efektem będzie wyczyszczony stałym kolorem obraz na nowo otwartym oknie, a także obsługa interakcji użytkownika z tymże oknem.

Utworzenie takiego programu jest banalnie proste przy pomocy API utworzonego modułu i z wyłączeniem komentarzy wymaga od aplikacji klienckiej jedynie 10 linijek prostego kodu, przedstawionego na listingu \ref{lst:demo:core:minimalWindow}. Jako porównania użyć można wzorcowego projektu zawartego w programie Visual Studio, który realizuje taką samą funkcję, ale wykonuje to znacznie bardziej złożonym kodem o objętości około 1000 linijek.

\vfill

\begin{lstlisting}[caption={Pełny kod programu wykorzystującego API modułu do utworzenia minimalnego okna.}, label={lst:demo:core:minimalWindow}]
	#include <URM/Core/D3DCore.h>
	
	int WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
		// Utworzenie struktury D3DCore z przekazaniem parametrów kreacji. 
		URM::Core::D3DCore core(
			URM::Core::WindowCreationParams(
				800,            // Szerokość okna
				600,            // Wysokość okna
				"EmptyWindow",  // Tytuł okna
				hInstance       // Uchwyt do instancji WinAPI
			)
		);
	    
		// Główna pętla programu działająca do momentu zamknięcia okna.
		while(!core.GetWindow().IsDestroyed()) {
			// Obsługa zdarzeń okna.
			core.GetWindow().PollEvents();

			// Czyszczenie zawartości okna zdefiniowanym kolorem.
			core.ClearFramebuffer(DirectX::SimpleMath::Color(0.3, 0.5, 1.0));

			// Prezentowanie wygenerowanej klatki obrazu na ekran.
			core.Present(0);
		}
	}
\end{lstlisting}

\subsection{Sponza}
Stworzona pierwotnie przez Marko Dabrovic'a, następnie ulepszona przez niemiecką firmę Crytek \cite{github:Khronos:Sponza}, a w 2022 roku ponownie usprawniona przez amerykańskiego giganta Intel \cite{Intel:GPUResearch:Sponza} reprezentacja rzeczywistego atrium pałacu Sponza, znajdującego się w Chorwackiej miejscowości Dubrovnik stała się jednym z najpopularniejszych modeli służących do testowania i porównywania programów grafiki 3D, a w szczególności modułów odpowiedzialnych za oświetlenie globalne. W ramach tej sekcji przedstawiona została najprostsza wersja od firmy Intel w dwóch wersjach - uproszczonej oraz PBR. W obu manualnie dobrane zostało oświetlenie oraz kolor nieba celem utworzenia kompozycji reprezentującej zbliżone do realnego zastosowanie modułu. W poniższej tabeli przedstawiona została także zmierzona wydajność renderowania, a wygenerowane zrzuty ekranu na rys. \ref{test_sponza_1}, \ref{test_sponza_2} i \ref{test_sponza_3}.

\begin{center}
	\begin{tabular}{ |l r r r|}
		\hline
		\textbf{Układ graficzny} & \textbf{FPS - uproszczony} & \textbf{FPS - PBR} & \textbf{Wydajność PBR} \\
		\hline
		NVIDIA 4060 & \textbf{955} & \textbf{718} & \textbf{75.18\%} \\
		Radeon 780M & \textbf{380} & \textbf{287} & \textbf{75.53\%} \\
		Procent wydajności & \textbf{39.79\%} & \textbf{39.79\%} & - \\
		\hline
	\end{tabular}
\end{center}

	
\begin{figure}[h!]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_1.png}
		\caption{Widok uproszczony.}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_1_pbr.png}
		\caption{Tryb PBR.}
	\end{subfigure}
	\caption{Hala atrium Sponza wygenerowana przez moduł.}
	\label{test_sponza_1}
\end{figure}

\begin{figure}[h!]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_2.png}
		\caption{Tryb klasyczny.}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_2_pbr.png}
		\caption{Widok PBR.}
	\end{subfigure}
	\caption{Zakrzywione stropy w korytarzach Sponza.}
	\label{test_sponza_2}
\end{figure}

\begin{figure}[h!]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_4.png}
		\caption{Shader uproszczony.}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_sponza_4_pbr.png}
		\caption{Wersja oparta o Physically Based Rendering.}
	\end{subfigure}
	\caption{Widok z piętra pałacu.}
	\label{test_sponza_3}
\end{figure}

\vfill
\clearpage

\subsection{Demo detali - Roman Marble Plinth}
Opisywany już w rozdziale testów model \textit{Roman Marble Ornate Plinth} z pakietu Quixel Megascans został głównym obiektem tej sekcji, ze względu na dużą ilość detali geometrii i tekstur. Przedstawiony w dwóch wersjach na rys. \ref{test_highpoly} model charakteryzuje się wysokim narzutem wydajnościowym przy rysowaniu, co dało wyraźny znak przy określaniu wydajności dema, czego szczegóły zostały przedstawione w poniższej tabeli.

\begin{center}
	\begin{tabular}{ |l r r r|}
		\hline
		\textbf{Układ graficzny} & \textbf{FPS - uproszczony} & \textbf{FPS - PBR} & \textbf{Wydajność PBR} \\
		\hline
		NVIDIA 4060 & \textbf{360} & \textbf{445} & \textbf{123.61\%} \\
		Radeon 780M & \textbf{84} & \textbf{84} & \textbf{100.00\%} \\
		Procent wydajności & \textbf{23.33\%} & \textbf{18.88\%} & - \\
		\hline
	\end{tabular}
\end{center}

\begin{figure}[h!]
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_highPoly.png}
		\caption{Wersja uproszczona.}
	\end{subfigure}
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/demo_highPoly_PBR.png}
		\caption{Tryb PBR.}
	\end{subfigure}
	\caption{Model cokołu w dwóch trybach działania modułu.}
	\label{test_highpoly}
\end{figure}

\subsection{Materiały}
Ostatnim demo przedstawiającym główne funkcjonalności modułu jest pokazanie możliwości zaimplementowanego systemu materiałów. Scena testu, pokazana na rys. \ref{demo_materials} składa się z 3 głównych części.
 
Głównym, środkowym elementem jest zbiór modeli kul o różnych parametrach materiałów. Elementy czerwone mają przypisany materiał typu PBR, a ich umieszczenie pokazuje różnice między jego parametrami. W osi pionowej od góry do dołu rośnie wartość chropowatości powierzchni - \textit{roughness}, a w poziomej od lewej do prawej parametr metaliczności. Kule zielone rysowane są przy pomocy uproszczonego materiału, a kolejne instancje zwiększają konfigurację chropowatości od lewej do prawej. 

Pozostałe segmenty przyjmują postać wydłużonych w pionie sześcianów, pokazujących bezproblemową możliwość doimplementowania dodatkowych materiałów. Wykorzystują one nowy materiał i przypisany do niego shader, niebędący częścią oryginalnego modułu, zwracający kolor odpowiadający pozycji na ekranie. Jego dwie instancje różnią się włączeniem i wyłączeniem kalkulacji oświetlenia, odpowiednio dla lewej i prawej wersji. 

Wygenerowana scena przedstawiona została na rys. \ref{demo_materials}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{images/demo_materials.png}
	\caption{Zrzut ekranu przedstawiający obiekty o różnych materiałach i programach cieniujących.}
	\label{demo_materials}
\end{figure}