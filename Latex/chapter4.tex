\chapter{Architektura oraz założenia systemu}
Przed faktycznym rozpoczęciem prac nad złożonym systemem programowym należy najpierw zastanowić się nad jego architekturą.
Ułatwia to określenie wymagań, celów, a także potencjalnych trudności które można napotkać w trakcie prac. 
Daje to możliwość zrewidowania architektury zanim poświęci się dużą ilość czasu na pisanie systemu z błędną architekturą.

\section{Rodzaje systemów rysujących}
Założeniem projektu jest stworzenie uniwersalnego, modularnego systemu rysującego.
Systemy tego typu przyjmują najczęściej formę punktu między dwoma ekstremami. 

Po jednej stronie spektrum znajduje się system prawie całkowicie niezależny. 
System taki zbliżony jest swoim działaniem do aplikacji wyświetlającej trójwymiarowy model w przestrzeni.
Moduł jest w takim przypadku odpowiedzialny za większość operacji związanych z rysowaniem, 
    w tym za inicjalizację okna, ruch kamery w odpowiedzi na interakcje z użytkownikiem,
    generowanie modelu 3D na podstawie pliku wejściowego, czy obliczanie zaawansowanych efektów świetlnych.
Aplikacja klienta w takim przypadku przekazuje jedynie ścieżkę do modelu oraz ogólne parametry sceny, takie jak pozycja oraz kierunek światła.

Przeciwieństwem jest moduł będący niewiele więcej niż abstrakcją nad niskopoziomowymi API graficznymi.
Udostępnia on uniwersalne API niezależne od systemu operacyjnego oraz końcowego API graficznego,
    nie zabierając przy tym kontroli nad procesem renderowania.
Wadą takiego rozwiązania jest zwiększony nakład pracy dla programisty aplikacji klienta,
    a także wynikające z abstrakcji ograniczenia funkcji końcowych API graficznych, które mogłyby być zaimplementowane w systemie pierwszego typu.

\section{Założenia projektowe - struktura warstwowa}
Projektowany system przyjmuje formę hybrydową.
Głównym założeniem wyróżniającym omawiany projekt względem innych, podobnych bibliotek, jest modularna struktura warstwowa.
Kolejne segmenty budują na poprzednich abstrahując coraz więcej elementów procesu renderowania.

Logistycznie projekt został podzielony na następujące warstwy:

\subsection{\textbf{Core} - Warstwa rdzeniowa}
Grupuje często używane funkcje oraz struktury z DirectX do łatwych w użyciu elementów obiektowych, takich jak Window, Shader, Framebuffer, czy Mesh.
Udostępnia funkcjonalność wczytywania z dysku plików tekstur i modeli.
Do zadań tej warstwy należy też zarządzenia pamięcią oraz cyklem życia obiektów.
Obiekty automatycznie zarządzają zasobami stosując inteligentne wskaźniki ze standardu C++11 oraz ComPtr z bibliotek WinAPI.

\subsection{\textbf{Scene} - Warstwa sceny}
Na tym poziomie znajdują się wysokopoziomowe struktury oraz metody wczytywania i zarządzania sceną oraz jej komponentami.
Automatyzowane jest tutaj między innymi wczytywanie z pliku pełnego modelu wraz z hierarchią, teksturami i parametrami materiałów.
Segment ten odpowiada też za zachowanie wzajemnych relacji między hierarchią obiektów z uwzględnieniem ich transformacji.

\subsection{\textbf{Engine} - Warstwa renderująca}
Warstwa odpowiadająca za większość procesu renderowania.
Aplikacja klienta przekazuje przy inicjalizacji parametry sceny, pozycje oraz ustawienia modeli, wirtualnej kamery i oświetlenia.
Wartości te mogą być modyfikowane w przekazanej do modułu funkcji typu callback, wywoływanej automatycznie przed rysowaniem kolejnej klatki obrazu.
Możliwe jest także przełączenie w tryb ręczny, w którym za wywoływanie funkcji rysowania oraz synchronizację odpowiedzialna jest aplikacja klienta.
Na tym poziomie obecna jest logika ułatwiająca pracę z buforami, oświetleniem, pakiet standardowych shader'ów czy menadżer zasobów.